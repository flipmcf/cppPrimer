exercise 2.1:

What are the differences between int, long, long long, and short?

--int, long and long long have different minimum storage sizes required by the C++ standard.  
16, 32 and 64 respectively, allowing them to store a larger range of values.
short and int both require at least 16 bits, so the difference between them is system and/or compiler dependent.

Between unsigned and signed:
  unsigned types represent only positive values, including zero.
  signed types represent values both negative and positive - generally equally balanced on both sides.
  
Between float and double:
  the number of _significant_digits_  (not scalar value) of double is larger than float.
  Standards say that floats carry a minimum of 6 sig digits, doubles have 10.
  
  
-----
To calculate a morgage payment, what types would you use for:
rate: double   (need 5, maybe 6 significant figures:  xx.xxxx)
principal: double
payment: double 

Basically, you need to be able to hold a decimal, and round to the nearest tenth of a penny, 
and display to the penny.

----------

exercise 2.23:  Predict the output:

unsigned u = 10, u2 = 42;
//noting that both are unsigned int's

std::cout << u2 - u << std::endl;
//This will output 32, becaue u < u2

std::cout << u - u2 << std::endl;
//This output is guaranteed to be a 'big, positive number' 
// because the output will also be an unsigned.
//  I guess, on my system, the answer will be the 32-bit 2's complement of the signed integer (-32)
//  4294967265
//  (but one cannot rely on this)

int i = 10, i2 = 42 // ok, now we have signed int's

std::cout << i2 - i << std::endl; // 32 
std::cout << i - i2 << std::endl; // -32 (yea signed!)

std::cout << i - u << std::endl; // 32
std::cout << u - i << std::endl;  //oops, but probably ok, barely.  result is 0.


=========
Exercise 2.5: Determine the type and explain the difference:
a: 'a' : Character - 8 bit
   L'a': Wide char (wchar_t) at least 16 bits
   "a":  string - 2 bytes - one for the 'a' and one for the null terminator '\0'
   L"a": string of wchar_t characters, followed by a null terminator
   
b: 10 : integer '10' base 10 type 'int' 
   10u : integer '10' base 10 type 'unsigned int' 
   10L : integer '10' base 10 type 'long'
   10uL : integer '10' base 10 type 'unsigned long'
   012  : octal '12' ( 10 in base 10 ) type 'int'
   0xC: : hex '0C' (12 in base 10) type 'int'
   
c: 3.14 : double
   3.14f : float
   3.14L : long double
   
d: 10  : int
   10u : unsigned int
   10. : double
   10e-2 : double
   
====
Exercise 2.6

int month=9, day=7;
int month=09, day=07;
// the difference between these two statements is that the first is base 10, the second is octal.
// additionally, 09 is an invalid octal #, and would probably be an error at compile time
//  -yes, it is "error: invalid digit "9" in octal constant

======
Exercise 2.7

a: "Who goes with F\145rgus?\012"
   This represents "Who goes with Fargus?" followed by a newline '\n' and ending with a null '\0'

b: 3.14e1L
     3.14 x 10^1 = 31.4  Stored in a long double
     
c: 1024f  
      1024.0 stored as a float
      
d: 3.14L
     3.14 stored as a long double
     
     
========
Exercise 2.9:
Explain:

a) std::cin >> int input_value;
    # Error: unexpected primary-expression before 'int'
    
b) int i = { 3.14 };
   #compiler warning: truncate a double to an int using list initialization
     
c) double salary = wage = 9999.99
   #invalid, error:  'wage' is undefined.
      
d) int i = 3.14;   # initialize i to '3' without warning - dangerous and without warning.
   
=======
Exercise 2.10:

What are the initial values:
 std::string global_str;
 int global_int;
 
 int main()
 {
    int local_int;
    std::string local_str;
 }

global_str = empty string
global_int = 0 (global scope)

local_int = undefined (local scope)
local_str = empty string (as defined by std::string class)


=====
Exercise 2.11:

Explain whether each of the following is a declaration or a definition
a) extern int ix = 1024;  // This is a definition because it is initialized
b) int iy;  // This is a definition because the 'extern' keyword is not present
c) extern int iz;  // this is a declaration - extern used and uninitialized

====
Exercise 2.12:
Which of these names are invalid:

a) int double = 3.14; //invalid: 'double' is a keyword
b) int _;  // this is valid (side note, usually is the name of the locale translator function, fyi)
c) int catch-22;  //invalid, the '-' character is not valid in an identifier
d) int 1_or_2 = 1; //invalid - starts with a numeric
e) double Double = 3.14 // valid (really?)


=====
Exercise 2.13:

what is the value of 'j' in the following:

int i = 42;
int main()
{
   int i = 100;
   int j = i
}

Answer: 100  (main i masks global i)

=====
exercise 2.14:

is the following progarm legal?  if so, what's the output:

int i = 100, sum = 0;
for (int i = 0; i != 10; ++i)
   sum += i;
std::cout << i << " " << sum << std::endl;

(before I try it) I would think that the output will be:
"100 45"
because the printed 'i' comes from the (global) scope, but the for loop defines and masks 'i'.

--cool - I was right

===
Finally, some cool stuff
===
Exercise 2.15 which of the following definitions, if any, are invalid, why?
a) int ival = 1.01;  //Valid, but you are truncating the decimal
b) int &rval1 = 1.01; //invalid - references must be initialized to objects, not literals
c) int &rval2 = ival; //valid.  
d) int &rval3;  //invalid - must initialize a reference

===
Exercise 2.16
Which assignments are are invalid.  If they are valid, describe what they do.

int i = 0, &r1 = i; double d = 0, &r2 = d;
a) r2 = 3.14159;  //Valid  d is assigned the value 3.14159
b) r1 = r2  //Invalid Type error (wrong - r1 is now '3')
c) i = r2;  //Invalid type error (wrong, i is now '3')
d) r1 = d   //Invalid type error (wrong, r1 is now '3') 
(must check these ....  see ex2.16.cpp)

--- WOAH!  they are all valid?  Assignments don't type check like declarations?
---- I predict some nasty bugs in my future here...
--
Corrected answers


====
Exercise 2.17:  What does this print?

int i, &ri = i;
i = 5; ri = 10;

std::cout << i << " " << ri << std::endl;

Answer:   "10 10"


====
Exercise 2.19:
Explain the key differences between pointers and references:

A reference is an "alias" to a named object.  It, itself, is not an object.
 References must point to an object and once it's defined, it cannot change.
 when you use the reference, you always get the object it refers to.

A pointer stores the address of an object, and is an object itself of type pointer.
 Pointers don't have to point to an object, they can be null.
 Pointers can be changed after definition (or assignment) to point to different objects.
 when you use a pointer, you (should / probably want to) dereference it to get the object it points to.

====
Exercise 2.20:
  What does this program do:
  
  int i = 42;   //declare 'i' and define it to have the value of '42'
  int *p1 = &i; //declare p1 as a pointer to an integer, and define it as the address of 'i'
  *p1 = *p1 * *p1;  //dereference p1 (value 42) and multuply it by dereference p1 (42) 
                    // and store it where p1 points to (i)
  
====
Exercise 2.21
 Explain each of the following definitions.  Indicate whether any are illegal and, if so, why
 
 int i = 0;

a) double* dp = &i;
   -- illegial.  i is an integer, db is a pointer to a double.  if it's not illegal, weirdness will ensue
   
b) int *ip = i;
   --- illegial.  cannot assign an integer to a pointer.
   
c) int *p = &i;
   --- legal.  p is now a pointer to i.
   
   
======
exercise 2.22:
Assuming p is a pointer to int, explain the following code:

if (p) //  convert the pointer to a bool.  Will be true if p is not 0 or nullptr
           "any non-zero pointer evaluates to true"
           
if (*p) // dereference p and convert the value in i to a bool.  True if i is non-zero
   
   
=====
exercise 2.23:
given a pointer p, can you determine whether p points to a valid object?
if so, how?  if not, why?

Short answer: No.  It's entirely possible to have p pointing to an invalid object.
Long answer: Yes, dereference it an pray that the program crashes. You probably shouldn't do it in production.  

(is there such a thing as C++ humor?)

=====

Exercise 2.24:
Why is the init of p legal bu that of lp illegial:

  int i = 42;
  void *p = &i;
  long *lp = &i;
  
p is legal because a void pointer does not do type checking.  
However, you can't convert a pointer to an integer to a pointer to a long.


=====
Exercise 2.25:
Determine types and values of each of the following variables:

a) int* ip, i, &r = i;
ip is a pointer to int - value undefined
i is an int - value undefined
r is a reference to the int i - value undefined

b) int i, *ip = 0;

i is an int - value undefined
ip is a pointer to int - value is 'null'

c) int* ip; ip2;
ip is a pointer to int - value undefined
ip2 is an int - value undefined






  
  